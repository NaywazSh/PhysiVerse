<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Young's Modulus 3D Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include OrbitControls for interactive camera movement --><script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #simulation-container {
            width: 100%;
            flex-grow: 1;
            min-height: 40vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #262c3a; /* Dark background for 3D scene */
            position: relative;
        }
        #info-panel {
            z-index: 10;
        }
        canvas {
            display: block;
        }
        .control-group {
            margin-bottom: 1rem;
        }
        .control-group label {
            font-weight: 600;
            color: #4b5563;
        }
        .value-display {
            font-size: 1.125rem;
            font-weight: 700;
            color: #10b981; /* Green color for results */
        }
    </style>
</head>
<body class="p-4">

    <h1 class="text-3xl font-bold mb-4 text-gray-800">Young's Modulus (E) Simulation</h1>

    <div id="simulation-container" class="rounded-xl shadow-2xl w-full">
        <!-- Three.js Canvas will be appended here --></div>

    <div id="control-panel" class="w-full max-w-4xl mt-6 p-6 bg-white rounded-xl shadow-lg flex flex-col md:flex-row gap-6">

        <!-- Input Controls --><div class="flex-1">
            <h2 class="text-xl font-semibold mb-3 text-gray-700">Inputs & Material</h2>

            <div class="control-group">
                <!-- FIX: Replaced $E$ with standard E -->
                <label for="material-select" class="block text-sm mb-1">Material (Young's Modulus, E)</label>
                <select id="material-select" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    <option value="200e9">Steel (200 GPa)</option>
                    <option value="70e9">Aluminum (70 GPa)</option>
                    <option value="3.5e9">Nylon (3.5 GPa)</option>
                </select>
            </div>

            <div class="control-group">
                <!-- FIX: Replaced $F$ with standard F -->
                <label for="force-input" class="block text-sm mb-1">Applied Force (F) in N</label>
                <input type="range" id="force-input" min="0" max="50000" step="100" value="10000" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="force-value" class="text-blue-600 font-mono text-sm">10000 N</span>
            </div>

            <div class="control-group">
                <!-- FIX: Replaced $\text{L}_o$ with L<sub>o</sub> -->
                <label for="length-input" class="block text-sm mb-1">Original Length (L<sub>o</sub>) in meters (m)</label>
                <input type="range" id="length-input" min="1" max="10" step="0.1" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="length-value" class="text-blue-600 font-mono text-sm">5.0 m</span>
            </div>

            <div class="control-group">
                <!-- FIX: Replaced $A$, $m^2$, and $W \times H$ with standard symbols -->
                <label for="area-input" class="block text-sm mb-1">Cross-sectional Area (A) in m&sup2; (Width W &times; Height H)</label>
                <input type="range" id="area-input" min="0.01" max="0.5" step="0.01" value="0.04" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="area-value" class="text-blue-600 font-mono text-sm">0.04 m²</span>
            </div>

        </div>

        <!-- Output Display --><div class="flex-1 bg-gray-50 p-4 rounded-lg">
            <h2 class="text-xl font-semibold mb-3 text-gray-700">Calculated Results</h2>

            <div class="control-group flex justify-between items-center">
                <!-- FIX: Used HTML entity for sigma -->
                <span class="text-sm text-gray-600">Applied Stress (&sigma; = F/A):</span>
                <span id="stress-result" class="value-display">0.00 MPa</span>
            </div>

            <div class="control-group flex justify-between items-center">
                <!-- FIX: Used HTML entities for epsilon, delta, and subscript for L -->
                <span class="text-sm text-gray-600">Tensile Strain (&epsilon; = &Delta;L / L<sub>o</sub>):</span>
                <span id="strain-result" class="value-display">0.000%</span>
            </div>

            <div class="control-group flex justify-between items-center">
                <span class="text-sm text-gray-600">Total Elongation (&Delta;L):</span>
                <span id="deltaL-result" class="value-display">0.000 m</span>
            </div>

            <div class="control-group flex justify-between items-center border-t pt-2 mt-2">
                <!-- FIX: Replaced $E$ with standard E -->
                <span class="text-lg font-bold text-gray-800">Young's Modulus (E):</span>
                <span id="youngs-modulus-display" class="value-display text-blue-600">200.0 GPa</span>
            </div>
        </div>

    </div>

    <script type="module">
        // --- CONSTANTS ---
        const VISUAL_SCALE = 10000; // Factor to make the tiny extension visible in 3D
        const VISUAL_SIZE_FACTOR = 3; // Factor to make the bar visually larger for visibility
        const MARKER_X_OFFSET = 0.5; // Horizontal offset for the L0 and Delta L markers
        const L0_MARKER_WIDTH_RATIO = 2; // L0 marker will be (Bar Width / 2) thick for prominence
        const DELTAL_MARKER_WIDTH_RATIO = 5; // Delta L marker will be (Bar Width / 5) thick.
        const L0_COLOR = 0x00FF88; // Greenish color for original length
        const DELTAL_COLOR = 0x00FF88; // Greenish color for elongation
        
        // Label offsets
        const F_LABEL_OFFSET_Z = 0.7; // Z-offset for F label from arrow
        const A_LABEL_OFFSET_Y = 0.7; // Y-offset for A label from bar top

        const E_VALUES = {
            "200e9": { label: "Steel", E: 200e9, color: 0xAAAAAA },
            "70e9": { label: "Aluminum", E: 70e9, color: 0xCCCCCC },
            "3.5e9": { label: "Nylon", E: 3.5e9, color: 0x00FF88 }
        };

        // --- THREE.JS SETUP ---
        let scene, camera, renderer, barMesh;
        let controls = {}; // Holds simulation controls and now OrbitControls
        let materialProperties = E_VALUES["200e9"];

        // Label references
        let labelLo, labelLn, labelDeltaL, labelA, labelF_R, labelF_L;

        const simContainer = document.getElementById('simulation-container');
        const forceInput = document.getElementById('force-input');
        const lengthInput = document.getElementById('length-input');
        const areaInput = document.getElementById('area-input');
        const materialSelect = document.getElementById('material-select');

        // --- INITIAL PARAMETERS ---
        controls.F = parseFloat(forceInput.value); // Force (N)
        controls.Lo = parseFloat(lengthInput.value); // Original Length (m)
        controls.A = parseFloat(areaInput.value); // Area (m^2)
        // Calculate visual dimensions based on physical area and scaling factor
        controls.W = Math.sqrt(controls.A) * VISUAL_SIZE_FACTOR; // Visual Width
        controls.H = controls.W; // Visual Height
        controls.E = materialProperties.E; // Young's Modulus (Pa)

        // --- HELPER FOR TEXTURES (SPRITES) ---
        function makeTextSprite(message, parameters) {
            if (parameters === undefined) parameters = {};
            const fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
            const fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 50;
            const borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 0;
            const borderColor = parameters.hasOwnProperty("borderColor") ? parameters["borderColor"] : { r: 0, g: 0, b: 0, a: 1.0 };
            const backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : { r: 0, g: 0, b: 0, a: 0.0 }; // Transparent background
            const textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : { r: 255, g: 255, b: 255, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = "Bold " + fontsize + "px " + fontface;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            canvas.width = textWidth + borderThickness;
            canvas.height = fontsize + borderThickness;

            // Re-set font after canvas resize
            context.font = "Bold " + fontsize + "px " + fontface;
            context.textBaseline = "middle"; // Center vertically
            context.textAlign = "center";   // Center horizontally

            context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
            context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

            context.lineWidth = borderThickness;
            context.fillRect(0, 0, canvas.width, canvas.height);
            if (borderThickness > 0) {
                context.strokeRect(0, 0, canvas.width, canvas.height);
            }

            context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", 1.0)";
            context.fillText(message, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter; // Smoother scaling

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width * 0.01, canvas.height * 0.01, 1); // Adjust scale to make text readable in 3D
            return sprite;
        }

        // --- CALCULATION FUNCTION ---
        function calculateDeformation() {
            const F = controls.F;
            const Lo = controls.Lo;
            const A = controls.A;
            const E = controls.E;

            // 1. Calculate Stress: Stress = F / A
            const stress = F / A; // Pa

            // 2. Calculate True Strain: Strain = Stress / E
            const strain = stress / E;

            // 3. Calculate True Elongation: Delta L = Strain * Lo
            const deltaL_true = strain * Lo; // m

            // 4. Calculate Visual Elongation (for Three.js)
            const deltaL_visual = deltaL_true * VISUAL_SCALE;

            return { stress, strain, deltaL_true, deltaL_visual };
        }

        // --- THREE.JS INITIALIZATION ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x262c3a); // Dark background color

            // Camera
            camera = new THREE.PerspectiveCamera(50, simContainer.clientWidth / simContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, controls.W * 1.5, controls.Lo * 2);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(simContainer.clientWidth, simContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            simContainer.appendChild(renderer.domElement);

            // Orbit Controls
            controls.orbit = new THREE.OrbitControls(camera, renderer.domElement);
            controls.orbit.enableDamping = true;
            controls.orbit.dampingFactor = 0.05;
            controls.orbit.screenSpacePanning = false;
            controls.orbit.minDistance = 2;
            controls.orbit.maxDistance = 50;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Bar Mesh (Initial State)
            const barGeometry = new THREE.BoxGeometry(controls.W, controls.H, controls.Lo);
            const barMaterial = new THREE.MeshPhongMaterial({
                color: materialProperties.color,
                specular: 0x444444,
                shininess: 20
            });
            barMesh = new THREE.Mesh(barGeometry, barMaterial);
            barMesh.position.z = 0;
            scene.add(barMesh);

            // Calculate proportional marker thickness
            const l0MarkerThickness = controls.W / L0_MARKER_WIDTH_RATIO; 
            const deltaLMarkerThickness = controls.W / DELTAL_MARKER_WIDTH_RATIO;

            // --- L0 Reference Marker (Greenish for original length) ---
            const l0Geometry = new THREE.BoxGeometry(l0MarkerThickness, l0MarkerThickness, controls.Lo);
            const l0Material = new THREE.MeshBasicMaterial({ color: L0_COLOR, transparent: true, opacity: 0.6 });
            controls.l0Marker = new THREE.Mesh(l0Geometry, l0Material);
            controls.l0Marker.position.set(-(controls.W / 2 + MARKER_X_OFFSET), 0, 0);
            controls.l0Marker.name = 'L0Marker';
            scene.add(controls.l0Marker);

            // --- Delta L Marker (Dynamic Greenish part) ---
            // Initial geometry size (will be updated immediately)
            const deltaLGeometry = new THREE.BoxGeometry(deltaLMarkerThickness, deltaLMarkerThickness, 0.001); 
            const deltaLMaterial = new THREE.MeshBasicMaterial({ color: DELTAL_COLOR });
            controls.deltaLMarker = new THREE.Mesh(deltaLGeometry, deltaLMaterial);
            controls.deltaLMarker.name = 'DeltaLMarker';
            scene.add(controls.deltaLMarker);

            // Create Force Arrow
            const arrowLength = controls.Lo * 0.5;
            const arrowColor = 0xFFA500; 

            // Force F (right side, positive Z)
            const dirR = new THREE.Vector3(0, 0, 1);
            const originR = new THREE.Vector3(0, 0, controls.Lo / 2 + 0.1);
            const arrowHelperR = new THREE.ArrowHelper(dirR, originR, arrowLength, arrowColor, controls.W * 0.2, controls.W * 0.2);
            arrowHelperR.name = 'ForceArrowR';
            scene.add(arrowHelperR);

            // Force F (left side, negative Z) - anchored
            const dirL = new THREE.Vector3(0, 0, -1);
            const originL = new THREE.Vector3(0, 0, -controls.Lo / 2 - 0.1);
            const arrowHelperL = new THREE.ArrowHelper(dirL, originL, arrowLength, arrowColor, controls.W * 0.2, controls.W * 0.2);
            arrowHelperL.name = 'ForceArrowL';
            scene.add(arrowHelperL);

            // --- Add Labels ---
            const whiteTextColor = { r: 255, g: 255, b: 255, a: 1.0 };
            const labelFontSize = 40;

            // Original Length Lo
            labelLo = makeTextSprite("original length L\u2080", { fontsize: labelFontSize, textColor: whiteTextColor });
            scene.add(labelLo);

            // New Length Ln
            labelLn = makeTextSprite("new length L\u2099", { fontsize: labelFontSize, textColor: whiteTextColor });
            scene.add(labelLn);

            // Delta L (Ln - L0) - Corrected text to match diagram more closely
            // Unicode for Delta is \u0394
            labelDeltaL = makeTextSprite("L\u2099 - L\u2080 (\u0394L)", { fontsize: labelFontSize, textColor: whiteTextColor });
            scene.add(labelDeltaL);

            // Area A
            labelA = makeTextSprite("A", { fontsize: labelFontSize, textColor: whiteTextColor });
            scene.add(labelA);

            // Force F (right)
            labelF_R = makeTextSprite("F", { fontsize: labelFontSize, textColor: whiteTextColor });
            scene.add(labelF_R);

            // Force F (left)
            labelF_L = makeTextSprite("F", { fontsize: labelFontSize, textColor: whiteTextColor });
            scene.add(labelF_L);


            window.addEventListener('resize', onWindowResize, false);

            // Initial render update
            updateSimulationVisuals();
        }

        // --- UPDATE FUNCTION ---
        function updateSimulationVisuals() {
            const { stress, strain, deltaL_true, deltaL_visual } = calculateDeformation();

            // --- 3D VISUAL UPDATE ---
            const scaleFactor = (controls.Lo + deltaL_visual) / controls.Lo;

            // Handle geometry and marker updates when physical dimensions change
            if (barMesh.geometry.parameters.depth !== controls.Lo || barMesh.geometry.parameters.width !== controls.W) {
                 
                 const l0MarkerThickness = controls.W / L0_MARKER_WIDTH_RATIO;
                 const deltaLMarkerThickness = controls.W / DELTAL_MARKER_WIDTH_RATIO;

                 // --- Update Bar Mesh ---
                 scene.remove(barMesh);
                 barMesh.geometry.dispose();
                 barMesh.material.dispose();
                 const newGeometry = new THREE.BoxGeometry(controls.W, controls.H, controls.Lo);
                 barMesh = new THREE.Mesh(newGeometry, new THREE.MeshPhongMaterial({
                    color: materialProperties.color,
                    specular: 0x444444,
                    shininess: 20
                 }));
                 scene.add(barMesh);

                 // --- Update L0 Marker ---
                 scene.remove(controls.l0Marker);
                 controls.l0Marker.geometry.dispose();
                 const l0Geometry = new THREE.BoxGeometry(l0MarkerThickness, l0MarkerThickness, controls.Lo);
                 const l0Material = new THREE.MeshBasicMaterial({ color: L0_COLOR, transparent: true, opacity: 0.6 });
                 controls.l0Marker = new THREE.Mesh(l0Geometry, l0Material);
                 controls.l0Marker.position.set(-(controls.W / 2 + MARKER_X_OFFSET), 0, 0);
                 controls.l0Marker.name = 'L0Marker';
                 scene.add(controls.l0Marker);


                 if (controls.orbit) {
                    camera.position.set(0, controls.W * 1.5, controls.Lo * 2); 
                    camera.lookAt(0, 0, 0);
                    controls.orbit.target.set(0, 0, 0);
                    controls.orbit.update();
                 }

                 // Update Arrow positions and size
                 const arrowR = scene.getObjectByName('ForceArrowR');
                 const arrowL = scene.getObjectByName('ForceArrowL');
                 if (arrowR && arrowL) {
                    const arrowLength = controls.Lo * 0.5;
                    arrowR.position.z = controls.Lo / 2 + 0.1;
                    arrowR.cone.scale.set(controls.W * 0.2, controls.W * 0.2, controls.W * 0.2); 
                    arrowL.position.z = -controls.Lo / 2 - 0.1;
                    arrowL.cone.scale.set(controls.W * 0.2, controls.W * 0.2, controls.W * 0.2); 
                 }
            }

            // Apply scale to bar to simulate elongation
            barMesh.scale.z = scaleFactor;
            // Shift the center by half the visual elongation to anchor the left side
            barMesh.position.z = deltaL_visual / 2;


            // --- Update Delta L Marker (The greenish part) ---
            const deltaLMarker = scene.getObjectByName('DeltaLMarker');
            if (deltaLMarker) {
                // Remove the old geometry and create a new one to accurately reflect length
                deltaLMarker.geometry.dispose();
                // Ensure a minimum size so it doesn't disappear completely
                const visualLength = Math.max(deltaL_visual, 0.0001); 
                
                const deltaLMarkerThickness = controls.W / DELTAL_MARKER_WIDTH_RATIO; // Recalculate thickness

                deltaLMarker.geometry = new THREE.BoxGeometry(deltaLMarkerThickness, deltaLMarkerThickness, visualLength);
                
                // Position: Start point of elongation (Lo/2) + half the new visual length (deltaL_visual/2)
                const markerX = -(controls.W / 2 + MARKER_X_OFFSET);
                const markerZ = controls.Lo / 2 + visualLength / 2;
                deltaLMarker.position.set(markerX, 0, markerZ);
                
                // Only show if there's actual elongation
                deltaLMarker.visible = deltaL_visual > 0.0001 && controls.F > 0;
            }

            // --- Update Label Positions (CORRECTED) ---
            const Lo_center_z = 0;
            const DeltaL_center_z = controls.Lo / 2 + deltaL_visual / 2;
            const Ln_center_z = deltaL_visual / 2;
            const y_offset_mid = -controls.H / 2 - 0.5; // Offset for Lo and Delta L
            const y_offset_low = -controls.H / 2 - 1.2; // Offset for Ln (stacked below)


            if (labelLo) {
                // X=0 (centered under bar), Y=Mid level, Z=Center of Lo
                labelLo.position.set(0, y_offset_mid, Lo_center_z); 
                labelLo.visible = true;
            }
            if (labelDeltaL) {
                // X=0, Y=Mid level, Z=Center of Delta L
                labelDeltaL.position.set(0, y_offset_mid, DeltaL_center_z);
                labelDeltaL.visible = deltaL_visual > 0.0001 && controls.F > 0;
            }
            if (labelLn) {
                // X=0, Y=Low level (to stack below Lo/DeltaL), Z=Center of Ln
                labelLn.position.set(0, y_offset_low, Ln_center_z); 
                labelLn.visible = true;
            }
            
            // Area A
            if (labelA) {
                // Positioned near the end face, slightly above the bar
                labelA.position.set(-controls.W / 2 - 0.5, controls.H / 2 + A_LABEL_OFFSET_Y, -controls.Lo / 2); 
                labelA.visible = true; 
            }
            // Force F (right)
            if (labelF_R) {
                // The z position must track the bar's extension
                labelF_R.position.set(0, 0, controls.Lo / 2 + F_LABEL_OFFSET_Z + deltaL_visual);
                labelF_R.visible = controls.F > 0;
            }
            // Force F (left)
            if (labelF_L) {
                // The z position is static at the fixed end
                labelF_L.position.set(0, 0, -controls.Lo / 2 - F_LABEL_OFFSET_Z);
                labelF_L.visible = controls.F > 0;
            }


            // --- UI DISPLAY UPDATE ---
            document.getElementById('youngs-modulus-display').textContent = `${(controls.E / 1e9).toFixed(1)} GPa`;
            document.getElementById('stress-result').textContent = `${(stress / 1e6).toFixed(2)} MPa`; // Convert Pa to MPa
            document.getElementById('strain-result').textContent = `${(strain * 100).toFixed(3)}%`; // Display as percentage
            document.getElementById('deltaL-result').textContent = `${(deltaL_true).toFixed(5)} m`;

            // Update force arrow visibility based on F
            const arrowR = scene.getObjectByName('ForceArrowR');
            const arrowL = scene.getObjectByName('ForceArrowL');
            const visibility = controls.F > 0;
            if(arrowR) arrowR.visible = visibility;
            if(arrowL) arrowL.visible = visibility;
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            if (renderer && controls.orbit) {
                controls.orbit.update(); // Update controls in the animation loop
                renderer.render(scene, camera);
            }
        }

        // --- EVENT HANDLERS ---
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = simContainer.clientWidth / simContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(simContainer.clientWidth, simContainer.clientHeight);
            }
        }

        function updateControls() {
            controls.F = parseFloat(forceInput.value);
            controls.Lo = parseFloat(lengthInput.value);
            controls.A = parseFloat(areaInput.value);
            // Recalculate visual dimensions using the scaling factor
            controls.W = Math.sqrt(controls.A) * VISUAL_SIZE_FACTOR;
            controls.H = controls.W;
            controls.E = materialProperties.E;

            // FIX: Update display units to use standard m² and kN
            document.getElementById('force-value').textContent = `${(controls.F / 1000).toFixed(1)} kN`;
            document.getElementById('length-value').textContent = `${controls.Lo.toFixed(1)} m`;
            document.getElementById('area-value').textContent = `${controls.A.toFixed(2)} m²`;

            // Update simulation visuals on control change
            updateSimulationVisuals();
        }

        // Event Listeners for UI inputs
        forceInput.addEventListener('input', updateControls);
        lengthInput.addEventListener('input', updateControls);
        areaInput.addEventListener('input', updateControls);

        materialSelect.addEventListener('change', () => {
            const E_key = materialSelect.value;
            materialProperties = E_VALUES[E_key];
            updateControls();
            
            // Update the mesh color
            if (barMesh) {
                barMesh.material.color.set(materialProperties.color);
            }
        });

        // Initialize and start the simulation
        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>
