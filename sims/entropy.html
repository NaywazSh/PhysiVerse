<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Second Law of Thermodynamics (Entropy) 3D Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0d1117; }
        #scene-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #info-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none; /* Allows mouse events to pass through to the canvas */
        }
        .temp-label {
            position: absolute;
            color: white;
            font-size: 2rem; /* Reduced size */
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
            user-select: none;
        }
        .flow-text {
            color: #ff8c00;
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
        }
        .caption-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 600px;
            padding: 1rem;
            background: rgba(18, 24, 32, 0.85);
            border: 1px solid #333;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            color: #e2e8f0;
            text-align: center;
            pointer-events: all; /* Make the box interactive */
            line-height: 1.4;
        }
        .highlight { color: #facc15; font-weight: bold; }
    </style>
</head>
<body>
    <div id="scene-container">
        <!-- Overlay for 2D text labels (easier than 3D text) -->
        <div id="info-overlay">
            <!-- Adjusted vertical position to top-[92%] (moved very close to the bottom) -->
            <div id="t1-label" class="temp-label top-[92%] -translate-y-1/2 left-1/4 -translate-x-1/2">T₁ (Hot)</div>
            <div id="t2-label" class="temp-label top-[92%] -translate-y-1/2 right-1/4 translate-x-1/2">T₂ (Cold)</div>
            <!-- Adjusted vertical position to top-[75%] (moved further down) -->
            <div class="absolute top-[75%] left-1/2 -translate-x-1/2 flow-text">
                ΔQ (Heat Flow) →
            </div>
            <div class="caption-box">
                <h1 class="text-xl mb-2 font-bold text-red-400">Second Law of Thermodynamics</h1>
                <p>
                    Observe the movement of molecules in the <span class="text-red-500">Hot Reservoir (T₁)</span> (High Entropy) vs. the <span class="text-blue-500">Cold Reservoir (T₂)</span> (Low Entropy).
                    <br>
                    Heat (<span class="highlight">ΔQ</span>) spontaneously flows from T₁ to T₂, increasing the total <span class="highlight">Entropy (ΔS)</span> of the universe, as shown by the red particles moving across the barrier.
                </p>
                <p class="mt-2 text-sm text-yellow-300">
                    Use mouse to drag/rotate (Orbit) and scroll to zoom.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Global variables for Three.js
        let scene, camera, renderer, controls;
        const MOLECULE_COUNT = 4000;
        const HOT_VELOCITY_SCALE = 0.08;
        const COLD_VELOCITY_SCALE = 0.02;
        const BOX_SIZE = 10;
        const BOX_OFFSET = 12;
        let particles = [];
        let heatParticles = [];

        // App ID for Firestore, though not used in this simulation.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- Utility Function to setup the scene ---
        function init() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // 1. Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d1117);

            // 2. Camera setup (Perspective Camera)
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 10, 40);

            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            // 4. Controls (Movement and Zoom)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // smooth rotation
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 100;

            // 5. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            // 6. Create Thermodynamic Elements
            createReservoirs();
            createMolecules();
            createHeatFlowPath();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Reservoir (Box) Creation ---
        function createReservoirs() {
            const geometry = new THREE.BoxGeometry(BOX_SIZE, BOX_SIZE, BOX_SIZE);

            // T1 (Hot) - Red
            const hotMaterial = new THREE.MeshPhongMaterial({ color: 0xcc0000, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const hotBox = new THREE.Mesh(geometry, hotMaterial);
            hotBox.position.x = -BOX_OFFSET;
            scene.add(hotBox);

            // T2 (Cold) - Blue
            const coldMaterial = new THREE.MeshPhongMaterial({ color: 0x0000cc, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const coldBox = new THREE.Mesh(geometry, coldMaterial);
            coldBox.position.x = BOX_OFFSET;
            scene.add(coldBox);

            // Connecting Bar (The barrier, separating the two systems)
            const connectionGeometry = new THREE.BoxGeometry(BOX_OFFSET * 2 - BOX_SIZE, BOX_SIZE / 4, BOX_SIZE / 4);
            const connectionMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const connection = new THREE.Mesh(connectionGeometry, connectionMaterial);
            connection.position.y = 0;
            scene.add(connection);
        }

        // --- Molecule/Particle System Creation ---
        function createMolecules() {
            const positions = new Float32Array(MOLECULE_COUNT * 3);
            const velocities = [];
            const colors = [];

            // Define the size and position of the boxes
            const halfBoxSize = BOX_SIZE / 2;

            const colorT1 = new THREE.Color(0xff8888); // Lighter red for particles
            const colorT2 = new THREE.Color(0x8888ff); // Lighter blue for particles
            const tempColors = [colorT1, colorT2];

            for (let i = 0; i < MOLECULE_COUNT; i++) {
                const isT1 = i < MOLECULE_COUNT / 2; // First half is T1 (Hot)

                // Set initial position
                const xOffset = isT1 ? -BOX_OFFSET : BOX_OFFSET;
                positions[i * 3 + 0] = xOffset + (Math.random() - 0.5) * BOX_SIZE; // X
                positions[i * 3 + 1] = (Math.random() - 0.5) * BOX_SIZE; // Y
                positions[i * 3 + 2] = (Math.random() - 0.5) * BOX_SIZE; // Z

                // Set initial velocity
                const scale = isT1 ? HOT_VELOCITY_SCALE : COLD_VELOCITY_SCALE;
                velocities.push(
                    (Math.random() - 0.5) * scale, // Vx
                    (Math.random() - 0.5) * scale, // Vy
                    (Math.random() - 0.5) * scale  // Vz
                );

                // Set color
                tempColors[isT1 ? 0 : 1].toArray(colors, i * 3);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            particles.userData.velocities = velocities;
            scene.add(particles);
        }

        // --- Heat Flow Visualization ---
        function createHeatFlowPath() {
            // This is a dynamic flow, represented by particles moving from T1 area to T2 area
            const flowGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const flowMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 });

            for (let i = 0; i < 50; i++) {
                const particle = new THREE.Mesh(flowGeometry, flowMaterial);

                // Start near T1
                particle.position.set(
                    -BOX_OFFSET + BOX_SIZE / 2 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );

                // Custom property for flow logic
                particle.userData.life = Math.random() * 100;
                particle.userData.speed = 0.1 + Math.random() * 0.1;
                particle.userData.active = true;
                heatParticles.push(particle);
                scene.add(particle);
            }
        }

        // --- Molecular Movement & Boundary Collision Logic ---
        function updateMolecules(delta) {
            if (!particles.geometry.attributes.position) return;

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            const halfBoxSize = BOX_SIZE / 2;

            for (let i = 0; i < MOLECULE_COUNT; i++) {
                const i3 = i * 3;

                // Update position
                positions[i3 + 0] += velocities[i3 + 0] * delta; // X
                positions[i3 + 1] += velocities[i3 + 1] * delta; // Y
                positions[i3 + 2] += velocities[i3 + 2] * delta; // Z

                // Determine which box the molecule belongs to
                const isT1 = positions[i3 + 0] < 0;
                const xOffset = isT1 ? -BOX_OFFSET : BOX_OFFSET;

                // Wall Collision (Reflection)
                for (let j = 0; j < 3; j++) {
                    const boxBoundary = (j === 0) ? xOffset + halfBoxSize : halfBoxSize;
                    const sign = (j === 0) ? Math.sign(positions[i3 + 0] - xOffset) : Math.sign(positions[i3 + j]);

                    if (Math.abs(positions[i3 + j] - (j === 0 ? xOffset : 0)) > boxBoundary) {
                        // Reflect position
                        positions[i3 + j] = (j === 0 ? xOffset : 0) + sign * boxBoundary * 0.98;

                        // Reverse velocity and add a little randomness for chaotic bounce
                        velocities[i3 + j] *= -1;
                        velocities[i3 + j] += (Math.random() - 0.5) * 0.005;
                    }
                }

                // Internal Barrier Check (Only bounce off the middle barrier)
                if (positions[i3 + 0] > -0.5 && positions[i3 + 0] < 0.5) {
                    // Force the particle back into its original box
                    if (isT1) {
                         positions[i3 + 0] = -0.51;
                         velocities[i3 + 0] *= -1;
                    } else {
                         positions[i3 + 0] = 0.51;
                         velocities[i3 + 0] *= -1;
                    }
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
        }

        // --- Heat Flow Animation Logic ---
        function updateHeatFlow(delta) {
            const flowStart = -BOX_OFFSET + BOX_SIZE / 2; // Right boundary of T1
            const flowEnd = BOX_OFFSET - BOX_SIZE / 2;    // Left boundary of T2
            const flowDuration = 100; // time steps for one flow cycle

            heatParticles.forEach(particle => {
                // Animate position: flow from T1 to T2
                particle.position.x += particle.userData.speed * delta;

                // If particle reaches the end, reset it back to the start
                if (particle.position.x > flowEnd) {
                    // Reset position near T1 exit
                    particle.position.x = flowStart;
                    particle.position.y = (Math.random() - 0.5) * 2;
                    particle.position.z = (Math.random() - 0.5) * 2;
                }
            });
        }

        // --- Main Animation Loop ---
        let clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            // Get delta time for frame rate independent movement
            const delta = clock.getDelta() * 60; // Scale by 60 for better control

            // 1. Update controls (for damping/smooth movement)
            controls.update();

            // 2. Update molecular motion
            updateMolecules(delta);

            // 3. Update heat flow visualization
            updateHeatFlow(delta);

            // 4. Render the scene
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // Start the simulation when the window loads
        window.onload = function () {
            init();
            animate();
        };

    </script>
</body>
</html>
