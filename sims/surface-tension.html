<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Surface Tension Simulation</title>
    <!-- Load Tailwind CSS for styling the UI --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls for camera interaction --><script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Black background */
        }
        canvas {
            display: block;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Make overlay take full height to position right side correctly */
            pointer-events: none;
            display: flex; /* Use flexbox for positioning */
            justify-content: space-between; /* Push items to ends */
        }
        .formula-text {
            font-size: 1.5rem; /* Larger font for formulas */
            font-weight: bold;
            color: #333;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>

    <div id="container"></div>

    <!-- UI Overlay fixed to the left and right --><div id="ui-overlay" class="p-4">
        <!-- Control box: w-64 h-64 square, aligned left --><div class="bg-white/80 backdrop-blur-sm p-4 rounded-lg shadow-xl mb-4 w-64 h-64 pointer-events-auto flex flex-col justify-around items-center text-center">
            <h1 class="text-xl font-bold text-blue-700">Liquid Surface Interaction (Jar Demo)</h1>
            <p class="text-sm text-gray-600">Use mouse/touch to rotate and zoom. Click the button to drop an object into the jar!</p>
            <button id="dropButton" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md hover:shadow-lg">
                Drop Object
            </button>
        </div>

        <!-- Formula Texts Box, aligned right --><div class="bg-white/80 backdrop-blur-sm p-4 rounded-lg shadow-xl mb-4 w-64 h-64 pointer-events-auto flex flex-col justify-around items-center text-center self-start ml-auto">
            <h2 class="text-xl font-bold text-blue-700 mb-2">Formulas:</h2>
            <div class="formula-text">
                γ = F / L
            </div>
            <div class="formula-text">
                F<sub>upward</sub> = T * 2πr
            </div>
        </div>
    </div>

    <script>
        // --- Global Constants and Variables ---
        let scene, camera, renderer, controls;
        let waterMesh, waterGeometry, waterMaterial;

        // Jar dimensions
        const JUG_HEIGHT = 10; // Total height of the container (from Y=0 to Y=10)
        const JUG_BODY_RADIUS = 5; // Uniform radius for the jar
        const waterLevel = JUG_HEIGHT / 2; // Y-coordinate of the water surface (5.0, half-filled)
        
        const DROPPED_OBJECTS = [];
        const container = document.getElementById('container');
        const dropButton = document.getElementById('dropButton');

        // --- Water Deformation Parameters ---
        const RIPPLE_DECAY = 0.98; // How fast the ripple dies down
        const RIPPLE_STRENGTH = 0.5; // How much a drop impacts the surface
        const RIPPLE_SPREAD = 1.5; // Radius of the ripple effect

        // Stores objects { index: i, originalY: y } for only the top vertices of the liquid body
        let originalYPositions = []; 

        // --- Utility Functions for Physics/Interaction ---

        /**
         * Simulates the visual effect of an object impacting the water surface.
         * This creates a localized dip and initiates a basic ripple by deforming the top cap vertices.
         * @param {THREE.Vector3} impactPosition - The world coordinates of the impact.
         */
        function applyImpact(impactPosition) {
            const positions = waterGeometry.attributes.position.array;

            // Only iterate through the identified top vertices
            originalYPositions.forEach(vertexData => {
                const i = vertexData.index; // Index into the geometry's attribute buffer

                // Get the vertex's local position (X, Y, Z)
                const localX = positions[i * 3];
                const localY = positions[i * 3 + 1]; // This is the height we deform
                const localZ = positions[i * 3 + 2];

                // Transform local position to world position for distance calculation
                const localVertex = new THREE.Vector3(localX, localY, localZ);
                const vertex = localVertex.clone().applyMatrix4(waterMesh.matrixWorld);

                // Calculate the horizontal distance from the impact point (in the XZ plane)
                const dx = vertex.x - impactPosition.x;
                const dz = vertex.z - impactPosition.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // Calculate the influence based on distance (using a Gaussian-like falloff)
                if (distance < RIPPLE_SPREAD) {
                    const normalizedDistance = distance / RIPPLE_SPREAD;
                    const dipFactor = Math.cos(normalizedDistance * Math.PI / 2); 
                    
                    // The vertical displacement is along the geometry's Y axis (index 1)
                    positions[i * 3 + 1] -= (dipFactor * RIPPLE_STRENGTH);
                }
            });

            waterGeometry.attributes.position.needsUpdate = true;
        }

        /**
         * Updates the water surface by decaying the ripples.
         * The surface tension effect is simulated by pulling displaced top vertices back towards the mean (original) height.
         */
        function updateWaterSurface() {
            const positions = waterGeometry.attributes.position.array;

            // Only iterate through the identified top vertices
            originalYPositions.forEach(vertexData => {
                const i = vertexData.index; // Index into the geometry's attribute buffer
                const originalHeight = vertexData.originalY; // Original local Y height

                // The height is the Y component (index 1)
                let height = positions[i * 3 + 1];
                
                // Calculate the displacement from the original height
                const displacement = height - originalHeight;

                // Dampen the displacement towards zero
                const newDisplacement = displacement * RIPPLE_DECAY;

                // Update the height (Y component)
                positions[i * 3 + 1] = originalHeight + newDisplacement;
            });

            waterGeometry.attributes.position.needsUpdate = true;
        }

        // --- Initialization ---

        function init() {
            // 1. Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black background

            // 2. Camera setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0, JUG_HEIGHT / 2, JUG_HEIGHT * 2);

            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // 4. Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, JUG_HEIGHT / 2, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 30;
            controls.update();

            // 5. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(5, 15, 8);
            scene.add(directionalLight);

            // 6. Create Jar (Container)
            createJar(); 

            // 7. Create Water Surface (now bulk liquid)
            createWater();

            // 8. Event Listener
            dropButton.addEventListener('click', dropObject);

            // 9. Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        /**
         * Creates a uniform cylindrical chemical jar.
         */
        function createJar() {
            // Create a common material for the jar walls (White and highly visible)
            const jarMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, // White color
                transparent: true,
                opacity: 0.8, // High opacity for visibility (frosted look)
                metalness: 0.1,
                roughness: 0.5, // Increased roughness for a matte/frosted effect
                transmission: 0.1, // Low transmission
                ior: 1.5,
                side: THREE.BackSide 
            });

            // --- Chemical Jar (Single Cylinder) ---
            const jarGeometry = new THREE.CylinderGeometry(JUG_BODY_RADIUS, JUG_BODY_RADIUS, JUG_HEIGHT, 32, 1, true);
            const jarMesh = new THREE.Mesh(jarGeometry, jarMaterial);
            jarMesh.position.y = JUG_HEIGHT / 2; // Center at Y=5 (half of 10)
            scene.add(jarMesh);

            // --- Base ---
            const baseGeometry = new THREE.CircleGeometry(JUG_BODY_RADIUS, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa, // Slightly darker base
                metalness: 0.2,
                roughness: 0.6,
                side: THREE.DoubleSide
            });
            const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
            baseMesh.rotation.x = -Math.PI / 2;
            baseMesh.position.y = 0.01; // Slightly above zero to avoid Z-fighting
            scene.add(baseMesh);
        }

        /**
         * Creates the liquid body as a cylinder and identifies the top vertices for deformation.
         */
        function createWater() {
            const radialSegments = 64; // High radial segments for smoothness
            const heightSegments = 10; // More segments to make the liquid body visible

            // Cylinder geometry for the liquid body, extending from Y=0 to Y=waterLevel
            waterGeometry = new THREE.CylinderGeometry(
                JUG_BODY_RADIUS, 
                JUG_BODY_RADIUS, 
                waterLevel,      
                radialSegments,
                heightSegments,
                false // OpenEnded: false, so it has a bottom cap
            );

            // Shift the cylinder up so its base is at Y=0 and its top edge is exactly at Y=waterLevel
            waterGeometry.translate(0, waterLevel / 2, 0);

            // Water material - semi-transparent, reflective, bulk liquid look
            waterMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x0099ff,
                transparent: true,
                opacity: 0.9, 
                metalness: 0.5,
                roughness: 0.2,
                reflectivity: 0.8,
                side: THREE.FrontSide, // Render the interior faces
            });

            waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
            scene.add(waterMesh);

            // Identify and Store Original Positions of TOP Vertices
            originalYPositions = [];
            const positions = waterGeometry.attributes.position.array;
            const vertexCount = waterGeometry.attributes.position.count;

            // The top surface vertices have a local Y coordinate of waterLevel / 2 after translation
            const topY = waterLevel / 2; 
            const tolerance = 0.01;

            for (let i = 0; i < vertexCount; i++) {
                const y = positions[i * 3 + 1]; // Y-coordinate is at index 1 in the buffer

                // Check if the vertex belongs to the top surface (cap)
                if (Math.abs(y - topY) < tolerance) {
                    // Store the index and original Y position (height) of the top vertex
                    originalYPositions.push({ 
                        index: i,
                        originalY: y 
                    });
                }
            }
        }

        /**
         * Creates and drops a new object (sphere) into the jar.
         */
        function dropObject() {
            const objectRadius = 0.5 + Math.random() * 0.5;
            const objectMass = objectRadius * 5; // Simple mass estimation

            const objectGeometry = new THREE.SphereGeometry(objectRadius, 32, 32);
            const objectMaterial = new THREE.MeshStandardMaterial({ 
                color: Math.random() * 0xffffff,
                metalness: 0.3,
                roughness: 0.4 
            });
            const objectMesh = new THREE.Mesh(objectGeometry, objectMaterial);

            // Start the object within the jar's radius
            const startRadius = JUG_BODY_RADIUS - objectRadius * 1.5; 
            const startX = (Math.random() - 0.5) * startRadius * 2;
            const startZ = (Math.random() - 0.5) * startRadius * 2;

            // Start high above the jar
            objectMesh.position.set(startX, JUG_HEIGHT * 1.5, startZ);

            const objectData = {
                mesh: objectMesh,
                radius: objectRadius,
                velocity: new THREE.Vector3(0, 0, 0),
                mass: objectMass,
                isSubmerged: false
            };

            DROPPED_OBJECTS.push(objectData);
            scene.add(objectMesh);
        }

        // --- Animation and Simulation Loop ---

        const gravity = new THREE.Vector3(0, -9.8, 0); // Standard gravity
        const DRAG_COEFFICIENT = 0.05; // Air drag
        const FLUID_DRAG = 0.5; // Water drag (much higher)
        const timeStep = 1 / 60; // Fixed time step for simulation

        function animate() {
            requestAnimationFrame(animate);

            controls.update(); // only required if controls.enableDamping is set to true

            // Update water surface ripples
            updateWaterSurface();

            // Physics simulation for dropped objects
            for (let i = DROPPED_OBJECTS.length - 1; i >= 0; i--) {
                const obj = DROPPED_OBJECTS[i];
                const mesh = obj.mesh;
                let force = new THREE.Vector3().copy(gravity).multiplyScalar(obj.mass);

                // Check for water interaction
                if (mesh.position.y - obj.radius <= waterLevel) {
                    // Object has impacted or is submerged
                    if (!obj.isSubmerged) {
                        // Impact detected! Trigger surface deformation
                        applyImpact(mesh.position);
                        obj.isSubmerged = true;
                        
                        // Apply a simple coefficient of restitution (bounce) to slow the fall
                        obj.velocity.y *= -0.1; 
                        
                        // Prevent the object from sinking too deep instantly
                        mesh.position.y = waterLevel + obj.radius - 0.01; 
                    }

                    // Apply fluid drag (for submerged objects)
                    const dragForce = obj.velocity.clone().multiplyScalar(-FLUID_DRAG);
                    force.add(dragForce);
                } else {
                    // Apply air drag (for falling objects)
                    const dragForce = obj.velocity.clone().multiplyScalar(-DRAG_COEFFICIENT);
                    force.add(dragForce);
                }
                
                // Update velocity (F = ma => a = F/m)
                const acceleration = force.divideScalar(obj.mass);
                obj.velocity.add(acceleration.multiplyScalar(timeStep));

                // Update position (p = p + v*t)
                mesh.position.add(obj.velocity.clone().multiplyScalar(timeStep));
                
                // Check for jar base collision (simple boundary)
                if (mesh.position.y - obj.radius < 0) {
                    mesh.position.y = obj.radius; // Rest on the base
                    obj.velocity.set(0, 0, 0); // Stop movement
                }

                // The jar radius is uniform
                const currentRadius = JUG_BODY_RADIUS; 

                // Check for jar walls (boundary)
                const distanceToCenter = Math.sqrt(mesh.position.x * mesh.position.x + mesh.position.z * mesh.position.z);
                if (distanceToCenter + obj.radius > currentRadius) {
                    // Simple inelastic wall collision
                    const normal = new THREE.Vector3(-mesh.position.x, 0, -mesh.position.z).normalize();
                    obj.velocity.reflect(normal).multiplyScalar(0.5);
                    // Push object slightly back inside
                    const correctionFactor = currentRadius / (distanceToCenter + obj.radius);
                    mesh.position.x *= correctionFactor;
                    mesh.position.z *= correctionFactor;
                }
            }

            renderer.render(scene, camera);
        }

        // --- Window Resize Handling ---

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            controls.update(); // Update controls after resize
        }

        // --- Start the Simulation ---
        window.onload = function() {
            init();
            animate();
            // Drop an initial object to show the effect immediately
            dropObject(); 
        }

    </script>
</body>
</html>
