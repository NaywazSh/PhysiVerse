<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Radioactivity Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js Library --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction --><script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0d0d1e; }
        canvas { display: block; }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            z-index: 100;
            max-width: 90vw;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.2);
            font-size: 0.9rem;
            border: 1px solid #00ffff55;
        }
        #decay-log {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 250px;
            max-height: 200px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #00ffff;
            padding: 10px;
            border-radius: 8px;
            overflow-y: auto;
            font-size: 0.8rem;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            border: 1px solid #00ffff33;
        }
        .log-entry {
            margin-bottom: 4px;
            border-bottom: 1px dashed #ffffff11;
            padding-bottom: 2px;
        }
    </style>
</head>
<body>

    <div id="info-panel">
        <h1 class="text-xl font-bold mb-1 text-cyan-400">Radioactivity Decay Simulation</h1>
        <p>Drag to rotate the atom. Particles decay periodically.</p>
        <div class="mt-2 flex justify-center space-x-4 text-xs">
            <span class="p-1 rounded-md bg-red-800">Proton (Red)</span>
            <span class="p-1 rounded-md bg-blue-800">Neutron (Blue)</span>
            <span class="p-1 rounded-md bg-green-800">Beta (Electron)</span>
            <span class="p-1 rounded-md bg-purple-800">Gamma (Photon)</span>
            <span class="p-1 rounded-md bg-amber-800">Alpha (He Nucleus)</span>
        </div>
        <p id="user-id-display" class="mt-2 text-xs text-gray-400"></p>
    </div>

    <div id="decay-log">
        <div class="text-center font-bold mb-2 text-white">Decay Log</div>
    </div>
    
    <script type="module">
        // --- Firebase Imports and Setup (MANDATORY) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId;

        const initializeFirebase = async () => {
            try {
                if (Object.keys(firebaseConfig).length > 0) {
                    const app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    // setLogLevel('debug'); // Enable for debugging

                    // Sign in using the custom token or anonymously
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                    
                    userId = auth.currentUser?.uid || crypto.randomUUID();
                    document.getElementById('user-id-display').textContent = `User ID: ${userId} | App ID: ${appId}`;
                } else {
                    console.warn("Firebase configuration not found. Running without authentication/persistence.");
                    userId = 'anonymous-' + crypto.randomUUID();
                }
            } catch (error) {
                console.error("Firebase initialization or sign-in failed:", error);
                userId = 'error-user-' + crypto.randomUUID();
            }
        };

        // --- Three.js Simulation Code ---

        let scene, camera, renderer, controls;
        let nucleusGroup = new THREE.Group();
        const particles = [];
        const decayingParticles = [];
        const NUM_PROTONS = 40;
        const NUM_NEUTRONS = 40;
        const NUCLEUS_RADIUS = 3.5;
        const NUCLEON_SIZE = 0.4; // Renamed for clarity (Proton/Neutron)
        const PARTICLE_SPEED = 0.05;
        let lastDecayTime = 0;
        const DECAY_INTERVAL = 2500; // milliseconds - slightly faster decay

        // Utility to generate a random point within a sphere
        function randomSpherePoint(radius) {
            let x, y, z, dist;
            do {
                x = (Math.random() * 2 - 1) * radius;
                y = (Math.random() * 2 - 1) * radius;
                z = (Math.random() * 2 - 1) * radius;
                dist = x * x + y * y + z * z;
            } while (dist > radius * radius);
            return new THREE.Vector3(x, y, z);
        }

        // Creates a sphere particle (Proton or Neutron)
        function createNucleon(isProton) {
            const color = isProton ? 0xFF0000 : 0x0000FF; // Red for Proton, Blue for Neutron
            const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
            const geometry = new THREE.SphereGeometry(NUCLEON_SIZE, 8, 8);
            const particle = new THREE.Mesh(geometry, material);
            
            // Initial random position in the nucleus
            particle.position.copy(randomSpherePoint(NUCLEUS_RADIUS));
            
            // Store properties for animation
            particle.originalPosition = particle.position.clone();
            particle.isProton = isProton;
            particle.jiggleOffset = Math.random() * 2 * Math.PI; // For random phase jiggle
            
            nucleusGroup.add(particle);
            particles.push(particle);
        }

        // Sets up the 3D scene
        function initScene() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // smooth rotation
            controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            // Create the initial nucleus
            for (let i = 0; i < NUM_PROTONS; i++) createNucleon(true);
            for (let i = 0; i < NUM_NEUTRONS; i++) createNucleon(false);
            scene.add(nucleusGroup);

            // Start the animation loop
            animate();
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Custom geometry for the Gamma Ray (oscillating wave)
        function createGammaRay(startPos, direction) {
            const points = [];
            const length = 10;
            const frequency = 5; // Slightly higher frequency
            const amplitude = 0.6; // Slightly higher amplitude

            const tangent = new THREE.Vector3().copy(direction).normalize();
            const initialUp = new THREE.Vector3(0, 1, 0);
            let orthogonalAxis = new THREE.Vector3().crossVectors(tangent, initialUp).normalize();
            if (orthogonalAxis.length() === 0) { // If tangent is parallel to initialUp (0,1,0)
                orthogonalAxis = new THREE.Vector3(1, 0, 0); // Use (1,0,0) as orthogonal axis
            }

            for (let i = 0; i < 50; i++) {
                const t = i / 49;
                const offset = Math.sin(t * Math.PI * frequency) * amplitude;
                const point = new THREE.Vector3().copy(tangent).multiplyScalar(t * length);
                point.add(new THREE.Vector3().copy(orthogonalAxis).multiplyScalar(offset));
                
                point.add(startPos);
                points.push(point);
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            // Use LineMaterial for thicker lines if possible, otherwise rely on LineBasicMaterial and its linewidth (which might be ignored by some renderers)
            const material = new THREE.LineBasicMaterial({ color: 0xaa00ff, linewidth: 5 }); // Purple, thicker line
            const line = new THREE.Line(geometry, material);

            // Store decay properties
            line.decayType = 'gamma';
            line.velocity = direction.multiplyScalar(0.15); // Faster gamma
            line.startTime = Date.now();
            line.duration = 2000; // ms
            
            return line;
        }


        // DECAY FUNCTIONS
        
        function emitAlphaDecay() {
            const alphaGroup = new THREE.Group();
            const direction = randomSpherePoint(1).normalize();
            const startPos = new THREE.Vector3();
            const startColor = 0xFF8800; // Orange/Amber

            const alphaNucleonSize = NUCLEON_SIZE * 1.5; // Make alpha particles bigger
            
            // The alpha particle consists of 2 protons and 2 neutrons. 
            const p1 = new THREE.Mesh(new THREE.SphereGeometry(alphaNucleonSize, 8, 8), new THREE.MeshPhongMaterial({ color: 0xFF0000 }));
            const p2 = new THREE.Mesh(new THREE.SphereGeometry(alphaNucleonSize, 8, 8), new THREE.MeshPhongMaterial({ color: 0xFF0000 }));
            const n1 = new THREE.Mesh(new THREE.SphereGeometry(alphaNucleonSize, 8, 8), new THREE.MeshPhongMaterial({ color: 0x0000FF }));
            const n2 = new THREE.Mesh(new THREE.SphereGeometry(alphaNucleonSize, 8, 8), new THREE.MeshPhongMaterial({ color: 0x0000FF }));

            // Arrange them close together
            const spacing = alphaNucleonSize * 0.8;
            p1.position.set(-spacing, spacing, 0);
            p2.position.set(spacing, spacing, 0);
            n1.position.set(-spacing, -spacing, 0);
            n2.position.set(spacing, -spacing, 0);

            alphaGroup.add(p1, p2, n1, n2);
            alphaGroup.position.copy(startPos);

            alphaGroup.decayType = 'alpha';
            alphaGroup.velocity = direction.multiplyScalar(0.06); // Slightly slower to emphasize mass
            alphaGroup.startTime = Date.now();
            alphaGroup.duration = 2800; // ms
            alphaGroup.name = 'alphaParticle'; // For identification
            alphaGroup.rotationSpeed = Math.random() * 0.05 + 0.02; // Add some rotation

            scene.add(alphaGroup);
            decayingParticles.push(alphaGroup);
            logDecay('Alpha Decay (He Nucleus)', startColor);
        }

        function emitBetaDecay() {
            const direction = randomSpherePoint(1).normalize();
            const startPos = new THREE.Vector3();
            const startColor = 0x00FF00; // Green (Electron)

            const betaParticleSize = NUCLEON_SIZE * 0.8; // Make beta particle noticeably larger than before
            const geometry = new THREE.SphereGeometry(betaParticleSize, 16, 16); // More detailed sphere
            // Use a BasicMaterial with strong emissive color for glow effect
            const material = new THREE.MeshBasicMaterial({ color: startColor, emissive: startColor, emissiveIntensity: 2.5 });
            const betaParticle = new THREE.Mesh(geometry, material);
            betaParticle.position.copy(startPos);

            betaParticle.decayType = 'beta';
            betaParticle.velocity = direction.multiplyScalar(0.25); // Even faster speed
            betaParticle.startTime = Date.now();
            betaParticle.duration = 1800; // ms
            betaParticle.name = 'betaParticle'; // For identification

            scene.add(betaParticle);
            decayingParticles.push(betaParticle);
            logDecay('Beta Decay (High Energy Electron)', startColor);
        }

        function emitGammaDecay() {
            const direction = randomSpherePoint(1).normalize();
            const startPos = new THREE.Vector3();
            const startColor = 0xAA00FF; // Purple (Photon)

            const gammaRay = createGammaRay(startPos, direction);
            gammaRay.name = 'gammaRay'; // For identification
            
            scene.add(gammaRay);
            decayingParticles.push(gammaRay);
            logDecay('Gamma Decay (High Energy Photon)', startColor);
        }

        // Logs the decay event to the UI
        function logDecay(type, color) {
            const logElement = document.getElementById('decay-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const colorHex = '#' + new THREE.Color(color).getHexString();
            entry.innerHTML = `<span style="color:${colorHex}; font-weight: bold;">[${Date.now() % 10000}]</span> Emitted: ${type}`;
            
            if (logElement.children.length > 10) {
                logElement.removeChild(logElement.children[1]); // Remove oldest entry (skip the title)
            }
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight; // Scroll to bottom
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            controls.update();

            // 1. Nucleus Jiggle Animation
            const time = currentTime * 0.001;
            particles.forEach(p => {
                // Subtle random vibration (jiggle)
                const jiggle = Math.sin(time * 5 + p.jiggleOffset) * 0.15;
                p.position.set(
                    p.originalPosition.x + Math.sin(time + p.jiggleOffset) * 0.05,
                    p.originalPosition.y + Math.cos(time * 0.8 + p.jiggleOffset) * 0.05,
                    p.originalPosition.z + Math.sin(time * 1.2 + p.jiggleOffset) * 0.05
                );
            });

            // 2. Decay Particle Movement and Cleanup
            for (let i = decayingParticles.length - 1; i >= 0; i--) {
                const p = decayingParticles[i];
                if (currentTime - p.startTime > p.duration) {
                    // Remove particle when duration is over
                    scene.remove(p);
                    decayingParticles.splice(i, 1);
                } else {
                    // Move particle
                    p.position.add(p.velocity);
                    // Add rotation for alpha particles
                    if (p.decayType === 'alpha') {
                        p.rotation.x += p.rotationSpeed;
                        p.rotation.y += p.rotationSpeed * 0.5;
                    }
                }
            }

            // 3. Decay Trigger
            if (currentTime - lastDecayTime > DECAY_INTERVAL) {
                lastDecayTime = currentTime;
                const decayType = Math.floor(Math.random() * 3);
                
                if (decayType === 0) {
                    emitAlphaDecay();
                } else if (decayType === 1) {
                    emitBetaDecay();
                } else {
                    emitGammaDecay();
                }
            }

            renderer.render(scene, camera);
        }
        
        // Ensure firebase is initialized before starting the scene
        window.onload = async function() {
            await initializeFirebase();
            initScene();
        }

    </script>
</body>
</html>
