<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Heat Engine Simulation - Final Adjusted</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            font-size: 1.1rem;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        #info span {
            color: #ffcc00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>3D Heat Engine Cycle Simulation</h2>
        Use mouse to <span>Orbit (Click & Drag)</span>, <span>Zoom (Scroll)</span>, and <span>Pan (Right Click & Drag)</span>.
    </div>
    <script>
        let scene, camera, renderer, controls;
        const mainScale = 0.8; // Adjust overall size

        // Utility function to create a label texture
        function createLabelTexture(text, bgColor, textColor, size = 64, padding = 10) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Reduced font size multiplier to 0.7 (was 1.4 in previous step)
            context.font = `${size * 0.7}px Inter`; 
            const textMetrics = context.measureText(text);
            const textWidth = textMetrics.width;
            const textHeight = size * 0.7; 

            canvas.width = textWidth + padding * 2;
            canvas.height = textHeight + padding * 2;

            context.fillStyle = bgColor;
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = `${size * 0.7}px Inter`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = textColor;
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // Function to add a 3D label plane
        function addLabel(text, position, rotation, color = "#ffffff", bgColor = "transparent", scale = 1, size = 48) {
            const labelTexture = createLabelTexture(text, bgColor, color, size);
            const labelMaterial = new THREE.MeshBasicMaterial({ map: labelTexture, transparent: true, side: THREE.DoubleSide });
            
            // Increased divisor to 40 (was 20 in previous step) to reduce plane size by half
            const labelGeometry = new THREE.PlaneGeometry(labelTexture.image.width / 40 * scale, labelTexture.image.height / 40 * scale);
            const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
            
            labelMesh.position.copy(position);
            if (rotation) labelMesh.rotation.copy(rotation);
            scene.add(labelMesh);
            return labelMesh; // Return the mesh for billboarding
        }

        // Function to create a 3D box (rectangle from 2D perspective)
        function createBox(width, height, depth, color, position, labelText = null) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshPhongMaterial({ color: color, shininess: 80 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);

            if (labelText) {
                // Label above the box, non-billboarded, fixed rotation
                addLabel(labelText, new THREE.Vector3(position.x, position.y + height / 2 + 1, position.z), new THREE.Euler(0, camera.rotation.y, 0), "#ffffff", "transparent", 0.7, 48);
            }
            return mesh;
        }

        // Function to create a 3D cylinder (pipe)
        function createCylinder(radius, height, color, position, rotation = null, labelText = null) {
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 16);
            const material = new THREE.MeshPhongMaterial({ color: color, shininess: 30 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            if (rotation) mesh.rotation.copy(rotation);
            scene.add(mesh);
             if (labelText) {
                 addLabel(labelText, new THREE.Vector3(position.x, position.y + (rotation && rotation.z === Math.PI/2 ? 2 * mainScale : height/2 + 0.5), position.z), null, "#ffffff", "transparent", 0.6, 48);
            }
            return mesh;
        }

        // Function to create an ArrowHelper
        function createFlowArrow(start, end, color, headLength = 1.5, headWidth = 0.8, text = null, textOffset = 2.5) {
            const dir = new THREE.Vector3().subVectors(end, start).normalize();
            const length = start.distanceTo(end);
            const arrowHelper = new THREE.ArrowHelper(dir, start, length, color, headLength, headWidth);
            scene.add(arrowHelper);

            if (text) {
                const textPos = new THREE.Vector3().addVectors(start, end).divideScalar(2);
                
                // Determine text position offset (always away from the arrow's main axis)
                const diff = new THREE.Vector3().subVectors(end, start);
                
                // Note: The diagram is primarily on the X-Y plane (Z is depth/3D effect)
                if (Math.abs(diff.x) > Math.abs(diff.y)) { // Primarily horizontal flow (X direction)
                    textPos.y += textOffset; // Offset perpendicular (in Y direction)
                } else if (Math.abs(diff.y) > Math.abs(diff.x)) { // Primarily vertical flow (Y direction)
                    textPos.x += textOffset; // Offset perpendicular (in X direction)
                } else { // Diagonal or purely Z (use Y offset as default)
                     textPos.y += textOffset;
                }
                
                // Specific adjustments for each label
                switch(text) {
                    case "work in":
                        textPos.x += -1.5 * mainScale; // Move left
                        textPos.y += 1 * mainScale; // Move up
                        break;
                    case "heat in":
                        textPos.x += -1 * mainScale; // Move left
                        textPos.y += 0.5 * mainScale; // Move up slightly
                        break;
                    case "heat out":
                        textPos.x += 1 * mainScale; // Move right
                        textPos.y += -0.5 * mainScale; // Move down slightly
                        break;
                    case "work out":
                        textPos.x += 1 * mainScale; // Move right
                        textPos.y += 0.5 * mainScale; // Move up slightly
                        break;
                    case "Q_H":
                        textPos.x += 1.5 * mainScale; // Move right
                        break;
                    case "W_out":
                        textPos.y += 1.5 * mainScale; // Move up
                        break;
                    case "Q_L":
                        textPos.x += -1.5 * mainScale; // Move left
                        break;
                }
                
                // Add the label. Rotation is null because we handle billboarding in animate().
                const label = addLabel(text, textPos, null, "#ffffff", "transparent", 0.6, 48);
                arrowHelper.userData.label = label; // Store label reference for billboarding
            }
            return arrowHelper;
        }

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 20, 100);

            // Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 15, 30);

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(scene.fog.color);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 10, 10).normalize();
            scene.add(directionalLight);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 60;

            // --- Left Diagram: Heat Engine Cycle ---
            const cycleOffset = new THREE.Vector3(-15 * mainScale, 0, 0); // Offset for the entire cycle diagram

            // Boiler
            const boilerPos = new THREE.Vector3(-8 * mainScale, 4 * mainScale, 0).add(cycleOffset);
            const boiler = createBox(5 * mainScale, 10 * mainScale, 2 * mainScale, 0x8b0000, boilerPos, "boiler"); // Dark Red
            // Add "bubbly" material for boiler fluid
            const boilerFluidGeo = new THREE.BoxGeometry(4.5 * mainScale, 6 * mainScale, 1.5 * mainScale);
            const boilerFluidMat = new THREE.MeshPhongMaterial({
                color: 0xff4500,
                specular: 0xcccccc,
                shininess: 100,
                transparent: true,
                opacity: 0.7
            });
            const boilerFluid = new THREE.Mesh(boilerFluidGeo, boilerFluidMat);
            boilerFluid.position.set(boilerPos.x, boilerPos.y - 1.5 * mainScale, boilerPos.z + 0.3 * mainScale);
            scene.add(boilerFluid);


            // Turbine
            const turbinePos = new THREE.Vector3(8 * mainScale, 4 * mainScale, 0).add(cycleOffset);
            const turbine = createCylinder(2 * mainScale, 3 * mainScale, 0xffa500, turbinePos, new THREE.Euler(0, 0, Math.PI / 2), "turbine"); // Orange, horizontal
            // Turbine blades (simple representation)
            for (let i = 0; i < 4; i++) {
                const blade = createBox(0.2 * mainScale, 2 * mainScale, 0.8 * mainScale, 0xaaaaaa, new THREE.Vector3(turbinePos.x, turbinePos.y, turbinePos.z));
                blade.rotation.z = i * Math.PI / 2;
                blade.parent = turbine; // Make blades rotate with turbine
            }


            // Condenser
            const condenserPos = new THREE.Vector3(8 * mainScale, -4 * mainScale, 0).add(cycleOffset);
            const condenser = createBox(6 * mainScale, 3 * mainScale, 2 * mainScale, 0x1e90ff, condenserPos, "condenser"); // Dodger Blue
            // Condenser coil (simplified)
            const coilGeo = new THREE.TorusGeometry(1.5 * mainScale, 0.3 * mainScale, 8, 16);
            const coilMat = new THREE.MeshPhongMaterial({ color: 0x87ceeb }); // Light blue
            const coil1 = new THREE.Mesh(coilGeo, coilMat);
            coil1.position.set(condenserPos.x, condenserPos.y, condenserPos.z + 0.5 * mainScale);
            coil1.rotation.x = Math.PI / 2;
            scene.add(coil1);

            // Pump
            const pumpPos = new THREE.Vector3(-8 * mainScale, -4 * mainScale, 0).add(cycleOffset);
            const pump = createCylinder(2 * mainScale, 3 * mainScale, 0x9400d3, pumpPos, new THREE.Euler(0, 0, Math.PI / 2), "pump"); // Dark Orchid, horizontal
             // Pump impeller (simple representation)
            for (let i = 0; i < 4; i++) {
                const blade = createBox(0.2 * mainScale, 2 * mainScale, 0.8 * mainScale, 0xaaaaaa, new THREE.Vector3(pumpPos.x, pumpPos.y, pumpPos.z));
                blade.rotation.z = i * Math.PI / 2;
                blade.parent = pump; // Make blades rotate with pump
            }

            // Piping
            const pipeRadius = 0.3 * mainScale;
            const pipeColor = 0x666666;

            // Boiler -> Turbine
            createCylinder(pipeRadius, (turbinePos.x - boilerPos.x) + 0.5 * mainScale, pipeColor, new THREE.Vector3((boilerPos.x + turbinePos.x) / 2, boilerPos.y + 2.5 * mainScale, boilerPos.z), new THREE.Euler(0, 0, Math.PI / 2));
            createCylinder(pipeRadius, 3 * mainScale, pipeColor, new THREE.Vector3(boilerPos.x, boilerPos.y + 2.5 * mainScale, boilerPos.z), new THREE.Euler(Math.PI / 2, 0, 0));
            createCylinder(pipeRadius, 3 * mainScale, pipeColor, new THREE.Vector3(turbinePos.x, turbinePos.y + 2.5 * mainScale, turbinePos.z), new THREE.Euler(Math.PI / 2, 0, 0));

            // Turbine -> Condenser
            createCylinder(pipeRadius, (turbinePos.y - condenserPos.y) + 0.5 * mainScale, pipeColor, new THREE.Vector3(turbinePos.x + 2.5 * mainScale, (turbinePos.y + condenserPos.y) / 2, turbinePos.z), new THREE.Euler(0, Math.PI / 2, 0));
            createCylinder(pipeRadius, 3 * mainScale, pipeColor, new THREE.Vector3(turbinePos.x + 2.5 * mainScale, turbinePos.y, turbinePos.z), new THREE.Euler(Math.PI / 2, 0, 0));
            createCylinder(pipeRadius, 3 * mainScale, pipeColor, new THREE.Vector3(condenserPos.x + 2.5 * mainScale, condenserPos.y, condenserPos.z), new THREE.Euler(Math.PI / 2, 0, 0));
            
            // Condenser -> Pump
            createCylinder(pipeRadius, (condenserPos.x - pumpPos.x) + 0.5 * mainScale, pipeColor, new THREE.Vector3((pumpPos.x + condenserPos.x) / 2, pumpPos.y - 2.5 * mainScale, pumpPos.z), new THREE.Euler(0, 0, Math.PI / 2));
            createCylinder(pipeRadius, 3 * mainScale, pipeColor, new THREE.Vector3(condenserPos.x, condenserPos.y - 2.5 * mainScale, condenserPos.z), new THREE.Euler(Math.PI / 2, 0, 0));
            createCylinder(pipeRadius, 3 * mainScale, pipeColor, new THREE.Vector3(pumpPos.x, pumpPos.y - 2.5 * mainScale, pumpPos.z), new THREE.Euler(Math.PI / 2, 0, 0));

            // Pump -> Boiler
            createCylinder(pipeRadius, (boilerPos.y - pumpPos.y) + 0.5 * mainScale, pipeColor, new THREE.Vector3(pumpPos.x - 2.5 * mainScale, (pumpPos.y + boilerPos.y) / 2, pumpPos.z), new THREE.Euler(0, Math.PI / 2, 0));
            createCylinder(pipeRadius, 3 * mainScale, pipeColor, new THREE.Vector3(pumpPos.x - 2.5 * mainScale, pumpPos.y, pumpPos.z), new THREE.Euler(Math.PI / 2, 0, 0));
            createCylinder(pipeRadius, 3 * mainScale, pipeColor, new THREE.Vector3(boilerPos.x - 2.5 * mainScale, boilerPos.y, boilerPos.z), new THREE.Euler(Math.PI / 2, 0, 0));


            // Arrows and Labels for the cycle diagram
            createFlowArrow(new THREE.Vector3(pumpPos.x, pumpPos.y - 2.5 * mainScale - 1.5 * mainScale, pumpPos.z), new THREE.Vector3(pumpPos.x, pumpPos.y - 2.5 * mainScale - 0.5 * mainScale, pumpPos.z), 0x9400d3, 0.8 * mainScale, 0.4 * mainScale, "work in", 3 * mainScale);
            createFlowArrow(new THREE.Vector3(boilerPos.x, boilerPos.y - 5.5 * mainScale, boilerPos.z), new THREE.Vector3(boilerPos.x, boilerPos.y - 6.5 * mainScale, boilerPos.z), 0xff8c00, 0.8 * mainScale, 0.4 * mainScale, "heat in", 3 * mainScale);
            
            createFlowArrow(new THREE.Vector3(turbinePos.x + 2.5 * mainScale + 0.5 * mainScale, turbinePos.y, turbinePos.z), new THREE.Vector3(turbinePos.x + 2.5 * mainScale + 1.5 * mainScale, turbinePos.y, turbinePos.z), 0x00ff00, 0.8 * mainScale, 0.4 * mainScale, "work out", 3 * mainScale);
            createFlowArrow(new THREE.Vector3(condenserPos.x + 2.5 * mainScale + 0.5 * mainScale, condenserPos.y, condenserPos.z), new THREE.Vector3(condenserPos.x + 2.5 * mainScale + 1.5 * mainScale, condenserPos.y, condenserPos.z), 0x1e90ff, 0.8 * mainScale, 0.4 * mainScale, "heat out", 3 * mainScale);


            // --- Right Diagram: Abstract Heat Engine ---
            const abstractOffset = new THREE.Vector3(15 * mainScale, 0, 0); // Offset for the abstract diagram

            // Hot Reservoir
            const hotReservoirPos = new THREE.Vector3(0, 8 * mainScale, 0).add(abstractOffset);
            createBox(10 * mainScale, 3 * mainScale, 2 * mainScale, 0x8b0000, hotReservoirPos, "Hot Reservoir");

            // Cold Reservoir
            const coldReservoirPos = new THREE.Vector3(0, -8 * mainScale, 0).add(abstractOffset);
            createBox(10 * mainScale, 3 * mainScale, 2 * mainScale, 0x00008b, coldReservoirPos, "Cold Reservoir");

            // Heat Engine Circle
            const engineCircleGeo = new THREE.CylinderGeometry(4 * mainScale, 4 * mainScale, 1 * mainScale, 32);
            const engineCircleMat = new THREE.MeshPhongMaterial({ color: 0xffff99, shininess: 80 }); // Light Yellow
            const heatEngineCircle = new THREE.Mesh(engineCircleGeo, engineCircleMat);
            heatEngineCircle.position.copy(abstractOffset);
            scene.add(heatEngineCircle);
            addLabel("Heat Engine", abstractOffset, new THREE.Euler(0, 0, 0), "#000000", "transparent", 0.8, 64);

            // Q_H arrow
            createFlowArrow(new THREE.Vector3(0, hotReservoirPos.y - 1.5 * mainScale, 0).add(abstractOffset), new THREE.Vector3(0, heatEngineCircle.position.y + 2 * mainScale, 0).add(abstractOffset), 0xff8c00, 1.2 * mainScale, 0.6 * mainScale, "Q_H", 3 * mainScale);
            
            // W_out arrow
            createFlowArrow(new THREE.Vector3(heatEngineCircle.position.x + 2 * mainScale, heatEngineCircle.position.y, 0).add(abstractOffset), new THREE.Vector3(heatEngineCircle.position.x + 7 * mainScale, heatEngineCircle.position.y, 0).add(abstractOffset), 0x00ff00, 1.2 * mainScale, 0.6 * mainScale, "W_out", 3 * mainScale);
            
            // Q_L arrow
            createFlowArrow(new THREE.Vector3(0, heatEngineCircle.position.y - 2 * mainScale, 0).add(abstractOffset), new THREE.Vector3(0, coldReservoirPos.y + 1.5 * mainScale, 0).add(abstractOffset), 0x1e90ff, 1.2 * mainScale, 0.6 * mainScale, "Q_L", 3 * mainScale);
            

            // Top Title
            addLabel("Heat Engine", new THREE.Vector3(0, 12 * mainScale, 0), null, "#ff0000", "transparent", 1.5, 96);


            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); 
            
            // Billboarding: Make all arrow labels face the camera for perfect readability
            scene.traverse(function(object) {
                if (object.isArrowHelper && object.userData.label) {
                    object.userData.label.lookAt(camera.position);
                }
                // Minimal animation: rotate turbine and pump blades
                if (object.parent && (object.parent.name === 'turbine' || object.parent.name === 'pump') && object.isMesh) {
                    object.rotation.z += 0.05; // Rotate blades
                }
            });

            renderer.render(scene, camera);
        }

        // Start the simulation when the window loads
        window.onload = function () {
            init();
            animate();
        }

    </script>
</body>
</html>
