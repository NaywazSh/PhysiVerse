<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Electric Field Interaction</title>
    <!-- Load Tailwind CSS for UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #scene-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1f2937; /* Dark background */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    
    <div class="fixed top-4 left-1/2 -translate-x-1/2 bg-white/10 backdrop-blur-sm p-3 rounded-xl shadow-lg border border-white/20 text-white z-10">
        <h1 class="text-lg font-bold">Electric Field Simulation (3D)</h1>
        <p class="text-sm">Drag the <span class="text-red-400 font-semibold">Positive (+)</span> and <span class="text-blue-400 font-semibold">Negative (-)</span> charges to see the field lines update.</p>
    </div>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let raycaster;
        let pointer = new THREE.Vector2();
        let currentIntersected = null;
        let isDragging = false;
        let dragObject = null;
        let plane = new THREE.Plane();
        let offset = new THREE.Vector3();
        let fieldLinesGroup;
        
        // Configuration: Grouping constants into one object to prevent global redeclaration errors
        const CONFIG = {
            LINE_COUNT: 60,       // Total number of field lines to draw
            STEP_SIZE: 0.5,       // Integration step size
            MAX_STEPS: 200,       // Max segments for a single line
            MAX_DISTANCE: 100,    // Stop if line goes too far
            CHARGE_RADIUS: 3,
            K: 1000               // Coulomb constant multiplier for visualization strength
        };

        // Charge Objects
        const charges = [
            { id: 0, mesh: null, position: new THREE.Vector3(-20, 0, 0), charge: 1, color: 0xff0000 }, // Positive
            { id: 1, mesh: null, position: new THREE.Vector3(20, 0, 0), charge: -1, color: 0x00aaff } // Negative
        ];
        
        // --- Physics Helpers ---
        
        /**
         * Calculates the Electric Field vector (E) at a point P due to a charge Q.
         * E = k * Q * (R / |R|^3), where R is the vector from Q to P.
         * @param {THREE.Vector3} P - The point to evaluate the field at.
         * @param {Object} chargeObj - The charge object {position, charge}.
         * @returns {THREE.Vector3} The Electric Field vector.
         */
        function calculateElectricField(P, chargeObj) {
            const R = new THREE.Vector3().subVectors(P, chargeObj.position);
            const rSquared = R.lengthSq();
            
            // Avoid division by zero when point P is at the charge location
            if (rSquared < 0.1) {
                return new THREE.Vector3(0, 0, 0); 
            }

            // E = k * q / r^2 * (R / r) = k * q * R / r^3
            const r = Math.sqrt(rSquared);
            const strength = CONFIG.K * chargeObj.charge / (rSquared * r);
            
            // E vector
            return R.multiplyScalar(strength);
        }

        /**
         * Calculates the Net Electric Field at a point P due to all charges.
         * @param {THREE.Vector3} P - The point to evaluate the net field at.
         * @returns {THREE.Vector3} The Net Electric Field vector.
         */
        function calculateNetElectricField(P) {
            let E_net = new THREE.Vector3(0, 0, 0);
            for (const chargeObj of charges) {
                E_net.add(calculateElectricField(P, chargeObj));
            }
            return E_net;
        }

        /**
         * Numerically traces an electric field line using the Euler method.
         * A field line is a path tangent to the net electric field at every point.
         * @param {THREE.Vector3} startPoint - The initial point for the line trace.
         * @param {number} traceSteps - How many steps to trace (max length).
         * @returns {THREE.BufferGeometry} A geometry object for the line.
         */
        function traceFieldLine(startPoint, traceSteps = CONFIG.MAX_STEPS) {
            const points = [startPoint.clone()];
            let currentP = startPoint.clone();

            const negativeChargePosition = charges.find(c => c.charge < 0).position;

            for (let i = 0; i < traceSteps; i++) {
                const E_net = calculateNetElectricField(currentP);
                
                // Stop condition 1: E-field is too weak or zero
                if (E_net.lengthSq() < 0.001) break; 
                
                // Stop condition 2: Line has moved too far from the origin
                if (currentP.length() > CONFIG.MAX_DISTANCE) break;
                
                // Stop condition 3: Line reached the negative charge (sink)
                if (currentP.distanceTo(negativeChargePosition) < CONFIG.CHARGE_RADIUS * 0.5) break;

                // Normalize E_net to get the direction vector (tangent)
                const direction = E_net.normalize();
                
                // Euler step: P_next = P_current + direction * step_size
                currentP.add(direction.multiplyScalar(CONFIG.STEP_SIZE));
                points.push(currentP.clone());
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            return geometry;
        }

        /**
         * Regenerates all field lines based on the current charge positions.
         */
        function regenerateFieldLines() {
            // Remove old lines
            if (fieldLinesGroup) {
                scene.remove(fieldLinesGroup);
            }
            
            fieldLinesGroup = new THREE.Group();
            scene.add(fieldLinesGroup);

            const positiveCharge = charges.find(c => c.charge > 0);
            if (!positiveCharge) return;

            // Material for the field lines
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc, linewidth: 1.5 });
            
            // Generate lines radiating from the positive charge
            const startRadius = CONFIG.CHARGE_RADIUS * 1.5;
            
            for (let i = 0; i < CONFIG.LINE_COUNT; i++) {
                // Determine a starting point on a sphere surface around the positive charge
                // Uses a spiral sampling method (Fibonacci sphere) for even distribution
                const goldenRatio = (1 + Math.sqrt(5)) / 2;
                const i_val = i;
                const phi = Math.acos(1 - 2 * i_val / CONFIG.LINE_COUNT);
                const theta = 2 * Math.PI * i_val / goldenRatio;

                const x = startRadius * Math.cos(theta) * Math.sin(phi);
                const y = startRadius * Math.sin(theta) * Math.sin(phi);
                const z = startRadius * Math.cos(phi);
                
                const startPoint = positiveCharge.position.clone().add(new THREE.Vector3(x, y, z));
                
                const geometry = traceFieldLine(startPoint);
                const line = new THREE.Line(geometry, lineMaterial);
                fieldLinesGroup.add(line);
            }
        }

        // --- Three.js Setup and Event Handlers ---
        
        function init() {
            const container = document.getElementById('scene-container');
            const width = window.innerWidth;
            const height = window.innerHeight;

            // 1. Scene
            scene = new THREE.Scene();

            // 2. Camera
            camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            camera.position.set(0, 0, 80);
            camera.lookAt(scene.position);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
            directionalLight.position.set(10, 10, 50).normalize();
            scene.add(directionalLight);

            // 5. Charges (Spheres)
            const sphereGeometry = new THREE.SphereGeometry(CONFIG.CHARGE_RADIUS, 32, 32);
            charges.forEach(charge => {
                const material = new THREE.MeshPhongMaterial({ 
                    color: charge.color,
                    emissive: charge.color,
                    emissiveIntensity: 0.5
                });
                const mesh = new THREE.Mesh(sphereGeometry, material);
                mesh.position.copy(charge.position);
                mesh.userData.chargeId = charge.id; // Store ID for identification
                charge.mesh = mesh;
                scene.add(mesh);
                
                // Add label (simple text using canvas texture or 3D text is complex, so we use a visual indicator)
                const indicatorColor = charge.charge > 0 ? 0xff0000 : 0x00aaff;
                const indicatorGeo = new THREE.CircleGeometry(CONFIG.CHARGE_RADIUS / 2, 32);
                const indicatorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
                
                // Create a basic + or - sign plane
                const sign = charge.charge > 0 ? "+" : "â€”";
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 64;
                ctx.font = 'bold 40px Arial';
                ctx.fillStyle = indicatorColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(sign, 32, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const signMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const signMesh = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.CHARGE_RADIUS * 1.5, CONFIG.CHARGE_RADIUS * 1.5), signMaterial);
                signMesh.rotation.y = Math.PI; // Face the camera
                
                mesh.add(signMesh);
                signMesh.position.z = CONFIG.CHARGE_RADIUS + 0.1; // Position slightly in front
            });

            // 6. Raycaster
            raycaster = new THREE.Raycaster();

            // 7. Initial Field Lines
            regenerateFieldLines();

            // 8. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Dragging Logic ---

        function onPointerDown(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Check for intersection with charges
            const intersects = raycaster.intersectObjects(charges.map(c => c.mesh));

            if (intersects.length > 0) {
                // A charge sphere was clicked
                dragObject = intersects[0].object;
                isDragging = true;
                
                // Calculate the plane perpendicular to the camera ray, passing through the clicked object
                plane.setFromNormalAndCoplanarPoint(camera.position.clone().normalize(), dragObject.position);
                
                // Calculate the offset between the object center and the intersection point on the plane
                raycaster.ray.intersectPlane(plane, offset);
                offset.sub(dragObject.position);

                // Change cursor and visual feedback
                document.body.style.cursor = 'grabbing';
            }
        }

        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging && dragObject) {
                // Perform the drag movement
                raycaster.setFromCamera(pointer, camera);
                
                let newPosition = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, newPosition);
                
                // Apply drag
                dragObject.position.copy(newPosition.sub(offset));
                
                // Keep Z position constant in world space (for a 2D drag effect)
                dragObject.position.z = 0; 
                
                // Update the charge data object
                const chargeData = charges.find(c => c.id === dragObject.userData.chargeId);
                if (chargeData) {
                    chargeData.position.copy(dragObject.position);
                }
                
                // Regenerate lines in real-time
                regenerateFieldLines();

            } else {
                // Hover effect
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(charges.map(c => c.mesh));

                if (intersects.length > 0) {
                    if (currentIntersected !== intersects[0].object) {
                        currentIntersected = intersects[0].object;
                        document.body.style.cursor = 'grab';
                    }
                } else if (currentIntersected) {
                    currentIntersected = null;
                    document.body.style.cursor = 'default';
                }
            }
        }

        function onPointerUp() {
            if (isDragging) {
                isDragging = false;
                dragObject = null;
                document.body.style.cursor = 'default';
                // Regenerate lines one final time (already done in pointermove, but good practice)
                regenerateFieldLines(); 
            }
        }

        // --- Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);

            // Rotate the charges slightly for a visual effect
            charges.forEach(c => {
                c.mesh.rotation.y += 0.005;
                c.mesh.rotation.x += 0.001;
            });

            renderer.render(scene, camera);
        }

        // Initialize the simulation when the window loads
        window.onload = init;
    </script>
</body>
</html>
